(defpackage #:lib.digest.generic
  (:use
   #:cl
   #:sb-gray
   #:lib.type
   #:lib.digest.common
   #:lib.symbol)
  (:export
   #:block-length
   #:buffer-index
   #:copy-digest
   #:defdigest
   #:define-digest-finalizer
   #:define-digest-registers
   #:define-digest-updater
   #:digest-length
   #:digestp
   #:end                                ; fixme
   #:finalize-registers
   #:make-digest
   #:mdx
   #:mdx-updater
   #:produce-digest
   #:start
   #:state
   #:store-data-length
   #:update-digest
   #:update-digest-from-stream
   #:update-digest-from-vector))

;;; defining digest (hash) functions

(in-package #:lib.digest.generic)

(defgeneric block-length (cipher)
  (:documentation "Return the number of bytes in an encryption or
decryption block for CIPHER.  CIPHER may either be a cipher name
as accepted by MAKE-CIPHER or a cipher object as returned by
MAKE-CIPHER.  NIL is returned if CIPHER does not name a known
cipher or is not a cipher object."))

(defgeneric copy-digest (digester &optional copy)
  (:documentation "Return a copy of DIGESTER.  If COPY is not NIL, it
should be of the same type as DIGESTER and will receive the copied data,
rather than creating a new object.  The copy is a deep copy, not a
shallow copy as might be returned by COPY-STRUCTURE."))

(defgeneric update-digest (digester thing &key &allow-other-keys)
  (:documentation "Update the internal state of DIGESTER with THING.
The exact method is determined by the type of THING."))

(defgeneric produce-digest (digester &key digest digest-start)
  (:documentation "Return the hash of the data processed by
DIGESTER so far.

If DIGEST is provided, the hash will be placed into DIGEST starting at
DIGEST-START.  DIGEST must be a ->u8.
An error will be signaled if there is insufficient room in DIGEST."))

(defgeneric digest-length (digest)
  (:documentation "Return the number of bytes in a digest generated by DIGEST."))

(eval-when (:compile-toplevel :load-toplevel)
  (defconstant +buffer-size+ (* 128 1024))
  (defconstant +seq-copy-buffer-size+ 512)
) ; EVAL-WHEN

(deftype buffer-index () `(integer 0 (,+buffer-size+)))

(defun update-digest-from-stream (digest stream &key buffer (start 0) end)
  (cond
    ((subtypep (stream-element-type stream) 'u8)
     (flet ((frob (read-buffer start end)
              (loop for last-updated = (read-sequence read-buffer stream
                                                      :start start :end end)
                 do (update-digest digest read-buffer
                                   :start start :end last-updated)
                 until (< last-updated end)
                 finally (return digest))))
       (if buffer
           (frob buffer start (or end (length buffer)))
           (let ((buffer (->u8 +buffer-size+)))
             (declare (dynamic-extent buffer))
             (frob buffer 0 +buffer-size+)))))
    (t
     (error 'ironclad-error
            :format-control "Unsupported stream element-type ~S for stream ~S."
            :format-arguments (list (stream-element-type stream) stream)))))

(declaim (inline update-digest-from-vector))

(defun update-digest-from-vector (digest vector start end)
  ;; SBCL and CMUCL have with-array-data, so copying can be avoided even
  ;; for non-simple vectors.
  (declare (type (vector ->u8) vector)
           (type array-index start end))
  (sb-kernel:with-array-data ((data vector) (real-start start) (real-end end))
   (declare (ignore real-end))
   (update-digest digest data :start real-start :end (+ real-start (- end start)))))

;;; Storing a length at the end of the hashed data is very common and
;;; can be a small bottleneck when generating lots of hashes over small
;;; quantities of data.  We assume that the appropriate locations have
;;; already been zeroed if necessary.  LENGTH is also assumed to be an
;;; (effectively) 64-bit quantity.
(declaim (inline store-data-length))
(defun store-data-length (block length offset &optional big-endian-p)
  (let ((lo (if big-endian-p (1+ offset) offset))
        (hi (if big-endian-p offset (1+ offset))))
    (setf (aref block lo) (ldb (byte 32 0) length)
          (aref block hi) (ldb (byte 32 32) length))))

;;; macros for "mid-level" functions

(defmacro define-digest-registers ((digest-name &key (endian :big) (size 4) (digest-registers nil)) &rest registers)
  (let* ((struct-name (symbolicate digest-name '#:-regs))
         (constructor (symbolicate '#:initial- struct-name))
         (copier      (symbolicate '#:copy- struct-name))
         (digest-fun  (symbolicate digest-name '#:-regs-digest))
         (register-bit-size (* size 8))
         (digest-size (* size (or digest-registers
                                  (length registers))))
         (ref-fun (ubref-fun-name register-bit-size (eq endian :big))))
    `(progn
       (eval-when (:compile-toplevel :load-toplevel :execute)
         (defstruct (,struct-name
                      (:type (vector (unsigned-byte ,register-bit-size)))
                      (:constructor ,constructor ())
                      (:copier ,copier))
           ,@registers)
         (deftype ,struct-name ()
           '(simple-array (unsigned-byte ,register-bit-size) (,(length registers)))))
       (defun ,digest-fun (regs buffer start)
         (declare (type ,struct-name regs)
                  (type ->u8 buffer)
                  (type (integer 0 ,(- array-dimension-limit digest-size)) start)
                  ,(burn-baby-burn))
         ,(let ((inlined-unpacking
                  `(setf ,@(loop for (reg value) in registers
                                 for index from 0 below digest-size by size
                                 nconc `((,ref-fun buffer (+ start ,index))
                                         (,(symbolicate digest-name '#:-regs- reg)
                                          regs))))))
               (cond
                 #+(and sbcl :little-endian)
                 ((eq endian :little)
                  `(if (and (= start 0) (<= ,register-bit-size sb-vm:n-word-bits))
                       (sb-kernel:ub8-bash-copy regs 0 buffer 0 ,digest-size)
                       ,inlined-unpacking))
                 #+(and sbcl :big-endian)
                 ((eq endian :big)
                  `(if (and (= start 0) (<= ,register-bit-size sb-vm:n-word-bits))
                       (sb-kernel:ub8-bash-copy regs 0 buffer 0 ,digest-size)
                       ,inlined-unpacking))
                 (t inlined-unpacking)))
         buffer))))

(defmacro define-digest-updater (digest-name &body body)
  (destructuring-bind (maybe-doc-string &rest rest) body
    `(defmethod update-digest ((state ,digest-name) (sequence vector) &key (start 0) (end (length sequence)))
       ,@(when (stringp maybe-doc-string)
               `(,maybe-doc-string))
       ,(hold-me-back)
       (check-type sequence ->u8)
       (check-type start array-index)
       (check-type end array-index)
       ,@(if (stringp maybe-doc-string)
             rest
             body))))

;;; SPECS is either (DIGEST-NAME DIGEST-BYTES) or a list of the same.
;;; The latter spelling is for digests that are related, but have
;;; different output sizes (e.g. SHA2-512 and SHA2-384).  In that case,
;;; the first list is expected to be for the "major" variant of the
;;; pair; its digest type is expected to be the supertype of the
;;; variants.
(defmacro define-digest-finalizer (specs &body body)
  (let* ((single-digest-p (not (consp (car specs))))
         (specs (if single-digest-p (list specs) specs))
         (inner-fun-name (symbolicate '#:finalize- (caar specs) '#:-state)))
    (destructuring-bind (maybe-doc-string &rest rest) body
      (let ((primary-digest (caar specs)))
        `(defmethod produce-digest ((state ,primary-digest)
                                    &key digest (digest-start 0))
           ,@(when (stringp maybe-doc-string)
               `(,maybe-doc-string))
           (flet ((,inner-fun-name (state digest digest-start)
                    (macrolet ((finalize-registers (state regs)
                                 (declare (ignorable state))
                                 (let ((clauses
                                         (loop for (digest-name digest-length) in ',specs
                                               collect `(,digest-name
                                                         (,(symbolicate digest-name '#:-regs-digest)
                                                          ,regs digest digest-start)))))
                                   (if ,single-digest-p
                                       (second (first clauses))
                                       (list* 'etypecase state
                                              (reverse clauses))))))
                      ,@(if (stringp maybe-doc-string)
                            rest
                            body))))
             (let ((digest-size ,(if single-digest-p
                                     (second (first specs))
                                     `(etypecase state
                                        ,@(reverse specs))))
                   (state-copy (copy-digest state)))
               (etypecase digest
                 (->u8
                  ;; verify that the buffer is large enough
                  (if (<= digest-size (- (length digest) digest-start))
                      (,inner-fun-name state-copy digest digest-start)
                      (error 'insufficient-buffer-space
                             :buffer digest :start digest-start
                             :length digest-size)))
                 (null
                  (,inner-fun-name state-copy
                                   (make-array digest-size
                                               :element-type 'u8)
                                   0))))))))))

;;; common superclass (superstructure?) for MD5-style digest functions

(defstruct (mdx
             (:constructor nil)
             (:copier nil))
  ;; This is technically an (UNSIGNED-BYTE 61).  But the type-checking
  ;; penalties that imposes on a good 32-bit implementation are
  ;; significant.  We've opted to omit the type declaration here.  If
  ;; you really need to digest exabytes of data, I'm sure we can work
  ;; something out.
  (amount 0)
  ;; Most "64-bit" digest functions (e.g. SHA512) will need to override
  ;; this initial value in an &AUX.
  (buffer (->u8 64) :read-only t :type ->u8)
  ;; This fixed type should be big enough for "64-bit" digest functions.
  (buffer-index 0 :type (integer 0 128)))

(declaim (inline mdx-updater))
(defun mdx-updater (state compressor seq start end)
  (declare (type mdx state))
  (declare (type function compressor))
  (declare (type array-index start end))
  (let* ((buffer (mdx-buffer state))
         (buffer-index (mdx-buffer-index state))
         (buffer-length (length buffer))
         (length (- end start)))
    (declare (type fixnum length))
    (unless (zerop buffer-index)
      (let ((amount (min (- buffer-length buffer-index)
                         length)))
        (copy-to-buffer seq start amount buffer buffer-index)
        (setq start (+ start amount))
        (let ((new-index (logand (+ buffer-index amount)
                                 (1- buffer-length))))
          (when (zerop new-index)
            (funcall compressor state buffer 0))
          (when (>= start end)
            (setf (mdx-buffer-index state) new-index)
            (incf (mdx-amount state) length)
            (return-from mdx-updater state)))))
    (loop until (< (- end start) buffer-length)
          do (funcall compressor state seq start)
             (setq start (the fixnum (+ start buffer-length)))
          finally (return
                    (let ((amount (- end start)))
                      (unless (zerop amount)
                        (copy-to-buffer seq start amount buffer 0))
                      (setf (mdx-buffer-index state) amount)
                      (incf (mdx-amount state) length)
                      state)))))

(declaim (notinline mdx-updater))

(defmacro defdigest (name &key digest-length block-length)
  `(progn
     (defmethod digest-length ((digest ,name))
       ,digest-length)
     (defmethod block-length ((digest ,name))
       ,block-length)))

;;; digesting streams

(defclass digesting-stream (fundamental-binary-output-stream)
  ((digest :initarg :digest :reader stream-digest)
   (buffer :initform (->u8 64)
           :reader stream-buffer)
   (position :initform 0
             :reader stream-buffer-position)))

(defmethod sb-gray::stream-element-type ((stream digesting-stream))
  'u8)

(defun make-digesting-stream (digest &rest args)
  (make-instance 'digesting-stream :digest (apply #'make-digest digest args)))

(defmethod sb-gray::stream-write-byte ((stream digesting-stream) byte)
  (declare (type u8 byte))
  (with-slots (digest buffer position) stream
    (setf (aref buffer position) byte)
    (when (= (incf position) 64)
      (update-digest digest buffer :start 0 :end 64)
      (setf position 0))
    byte))

(defmethod stream-write-sequence
           ((stream digesting-stream) seq &optional (start 0) end)
  (typecase seq
    (->u8
     (let ((end (or end (length seq))))
       (unless (zerop (stream-buffer-position stream))
         (update-digest (stream-digest stream) (stream-buffer stream) :end
                        (stream-buffer-position stream))
         (setf (slot-value stream 'position) 0))
       (update-digest (stream-digest stream) seq :start start :end end)
       seq))
    (t (call-next-method))))

(defmethod sb-gray::stream-clear-output ((stream digesting-stream))
  (with-slots (digest position) stream
    (setf position 0)
    (reinitialize-instance digest)
    nil))

(defmethod produce-digest ((stream digesting-stream)
                           &key digest (digest-start 0))
  (with-slots ((%digest digest) buffer position) stream
    (unless (zerop position)
      (update-digest %digest buffer :start 0 :end position)
      (setf position 0))
    (produce-digest %digest :digest digest :digest-start digest-start)))

(defun execute-with-digesting-stream (digest fn)
  (with-open-stream (stream (make-digesting-stream digest))
    (funcall fn stream)
    (produce-digest stream)))

(defmacro with-digesting-stream ((var digest &rest args) &body body)
  `(with-open-stream (,var (make-digesting-stream ,digest ,@args))
     ,@body
     (produce-digest ,var)))
