;;;; Core validation system with applicative validation pattern
;;;; Provides composable validators with error accumulation

(defpackage epsilon.validation
  (:use cl)
  (:local-nicknames
   (map epsilon.map)
   (seq epsilon.sequence)
   (str epsilon.string))
  (:export
   ;; Result types
   validation-result
   validation-success
   validation-failure
   validation-error
   make-success
   make-failure
   validation-result-p
   validation-success-p
   validation-failure-p
   validation-errors
   validation-value
   
   ;; Error construction
   make-validation-error
   validation-error-field
   validation-error-message
   validation-error-type
   validation-error-context
   
   ;; Combinators
   validate
   validate-all
   validate-map
   validate-when
   combine-results
   
   ;; Core validators
   validator
   required
   optional
   type-validator
   string-type
   integer-type
   number-type
   boolean-type
   list-type
   plist-type
   
   ;; Constraint validators
   min-length
   max-length
   length-between
   non-empty
   unique-items
   matches-regex
   one-of
   none-of
   satisfies-predicate
   
   ;; Composite validators
   all-of
   any-of
   chain
   transform
   
   ;; Multi-stage validation
   stage
   multi-stage
   run-stages))

(in-package epsilon.validation)

;;;; Result Types

(defstruct validation-result
  "Base type for validation results")

(defstruct (validation-success (:include validation-result))
  "Successful validation result"
  (value nil))

(defstruct (validation-failure (:include validation-result))
  "Failed validation result with accumulated errors"
  (errors '() :type list))

(defstruct validation-error
  "Individual validation error"
  (field nil :type (or string null))
  (message "" :type string)
  (type :invalid :type keyword)
  (context nil))

(defun make-success (value)
  "Create a successful validation result"
  (make-validation-success :value value))

(defun make-failure (errors)
  "Create a failed validation result"
  (make-validation-failure 
   :errors (if (listp errors) errors (list errors))))

;;;; Result Predicates
;; Note: validation-success-p and validation-failure-p are automatically
;; generated by defstruct, so we don't need to define them here

(defun validation-value (result)
  "Extract value from successful result"
  (when (validation-success-p result)
    (validation-success-value result)))

(defun validation-errors (result)
  "Extract errors from failed result"
  (when (validation-failure-p result)
    (validation-failure-errors result)))

;;;; Combinators

(defun combine-results (results)
  "Combine multiple validation results using applicative semantics.
   If all succeed, returns success with list of values.
   If any fail, returns failure with all errors accumulated."
  (let ((errors '())
        (values '()))
    (dolist (result results)
      (if (validation-failure-p result)
          (setf errors (append errors (validation-errors result)))
          (push (validation-value result) values)))
    (if errors
        (make-failure errors)
        (make-success (nreverse values)))))

(defun validate (validator value &optional field-name)
  "Apply a validator to a value, optionally with field context"
  (let ((result (funcall validator value)))
    ;; Add field context to errors if provided
    (when (and field-name (validation-failure-p result))
      (setf result 
            (make-failure
             (mapcar (lambda (error)
                       (if (validation-error-field error)
                           ;; Prepend field name to existing path
                           (let ((new-error (copy-structure error)))
                             (setf (validation-error-field new-error)
                                   (format nil "~A.~A" field-name 
                                          (validation-error-field error)))
                             new-error)
                           ;; Set field name if not already set
                           (let ((new-error (copy-structure error)))
                             (setf (validation-error-field new-error) field-name)
                             new-error)))
                     (validation-errors result)))))
    result))

(defun validate-all (validators value)
  "Apply multiple validators to the same value, accumulating all errors"
  (combine-results
   (mapcar (lambda (v) (funcall v value)) validators)))

(defun validate-map (validator-map data-map)
  "Validate a map/plist against a map of validators"
  (let ((results '()))
    (map:each (lambda (field validator)
                (let ((value (map:get data-map field)))
                  (push (validate validator value (string field)) results)))
              validator-map)
    (let ((combined (combine-results results)))
      (if (validation-success-p combined)
          ;; Return validated map
          (make-success data-map)
          combined))))

(defun validate-when (predicate validator)
  "Apply validator only when predicate is true"
  (lambda (value)
    (if (funcall predicate value)
        (funcall validator value)
        (make-success value))))

;;;; Core Validators

(defun validator (fn error-message &key (type :invalid))
  "Create a validator from a predicate function"
  (lambda (value)
    (if (funcall fn value)
        (make-success value)
        (make-failure
         (list (make-validation-error
                :message error-message
                :type type))))))

(defun required (value)
  "Validate that value is present (not nil or empty string)"
  (cond
    ((null value)
     (make-failure
      (list (make-validation-error
             :message "is required"
             :type :missing))))
    ((and (stringp value) (str:empty-p value))
     (make-failure
      (list (make-validation-error
             :message "cannot be empty"
             :type :empty))))
    (t (make-success value))))

(defun optional (validator)
  "Make a validator optional (succeeds on nil)"
  (lambda (value)
    (if (null value)
        (make-success nil)
        (funcall validator value))))

(defun type-validator (type-name type-predicate)
  "Create a type validator"
  (validator type-predicate
             (format nil "must be ~A" type-name)
             :type :type-error))

(defun string-type (value)
  "Validate string type"
  (funcall (type-validator "a string" #'stringp) value))

(defun integer-type (value)
  "Validate integer type"
  (funcall (type-validator "an integer" #'integerp) value))

(defun number-type (value)
  "Validate number type"
  (funcall (type-validator "a number" #'numberp) value))

(defun boolean-type (value)
  "Validate boolean type"
  (funcall (type-validator "a boolean" (lambda (v) (member v '(t nil)))) value))

(defun list-type (value)
  "Validate list type"
  (funcall (type-validator "a list" #'listp) value))

(defun plist-type (value)
  "Validate property list type"
  (funcall (validator
            (lambda (v)
              (and (listp v)
                   (evenp (length v))
                   (loop for key in v by #'cddr
                         always (keywordp key))))
            "must be a property list"
            :type :type-error)
           value))

;;;; Constraint Validators

(defun min-length (min)
  "Validate minimum length"
  (validator
   (lambda (value)
     (and (or (stringp value) (listp value))
          (>= (length value) min)))
   (format nil "must have at least ~D items" min)
   :type :constraint))

(defun max-length (max)
  "Validate maximum length"
  (validator
   (lambda (value)
     (and (or (stringp value) (listp value))
          (<= (length value) max)))
   (format nil "must have at most ~D items" max)
   :type :constraint))

(defun length-between (min max)
  "Validate length is between min and max"
  (all-of (list (min-length min) (max-length max))))

(defun non-empty ()
  "Validate that collection is not empty"
  (validator
   (lambda (value)
     (and (or (stringp value) (listp value))
          (> (length value) 0)))
   "cannot be empty"
   :type :constraint))

(defun unique-items ()
  "Validate that list has unique items"
  (validator
   (lambda (value)
     (and (listp value)
          (= (length value)
             (length (remove-duplicates value :test #'equal)))))
   "must contain unique items"
   :type :constraint))

(defun matches-regex (pattern)
  "Validate string matches pattern (simplified)"
  (validator
   (lambda (value)
     (and (stringp value)
          ;; Simplified pattern matching for now
          (or (search pattern value)
              (string= pattern value))))
   (format nil "must match pattern ~A" pattern)
   :type :constraint))

(defun one-of (options)
  "Validate value is one of allowed options"
  (validator
   (lambda (value)
     (member value options :test #'equal))
   (format nil "must be one of: ~{~A~^, ~}" options)
   :type :constraint))

(defun none-of (options)
  "Validate value is not in forbidden options"
  (validator
   (lambda (value)
     (not (member value options :test #'equal)))
   (format nil "must not be one of: ~{~A~^, ~}" options)
   :type :constraint))

(defun satisfies-predicate (predicate description)
  "Validate value satisfies custom predicate"
  (validator predicate description :type :constraint))

;;;; Composite Validators

(defun all-of (validators)
  "All validators must pass (accumulates errors)"
  (lambda (value)
    (validate-all validators value)))

(defun any-of (validators)
  "At least one validator must pass"
  (lambda (value)
    (let ((results (mapcar (lambda (v) (funcall v value)) validators)))
      (if (some #'validation-success-p results)
          ;; Return first success
          (find-if #'validation-success-p results)
          ;; All failed, combine errors
          (make-failure
           (list (make-validation-error
                  :message (format nil "none of ~D validators passed" 
                                  (length validators))
                  :type :any-of
                  :context (mapcan #'validation-errors results))))))))

(defun chain (&rest validators)
  "Chain validators, passing result through each"
  (lambda (value)
    (reduce (lambda (result validator)
              (if (validation-success-p result)
                  (funcall validator (validation-value result))
                  result))
            validators
            :initial-value (make-success value))))

(defun transform (transformer validator)
  "Transform value before validation"
  (lambda (value)
    (funcall validator (funcall transformer value))))

;;;; Multi-stage Validation

(defstruct validation-stage
  "A named validation stage"
  (name nil :type (or string null))
  (validator nil :type function)
  (continue-on-failure nil :type boolean))

(defun stage (name validator &key (continue-on-failure nil))
  "Create a named validation stage"
  (make-validation-stage
   :name name
   :validator validator
   :continue-on-failure continue-on-failure))

(defun multi-stage (stages)
  "Create a multi-stage validator"
  (lambda (value)
    (let ((all-errors '())
          (current-value value))
      (dolist (stage stages)
        (let ((result (funcall (validation-stage-validator stage) current-value)))
          (cond
            ((validation-success-p result)
             (setf current-value (validation-value result)))
            (t
             ;; Add stage context to errors
             (let ((stage-errors
                    (mapcar (lambda (error)
                              (let ((new-error (copy-structure error)))
                                (setf (validation-error-context new-error)
                                      (cons (validation-stage-name stage)
                                            (validation-error-context error)))
                                new-error))
                            (validation-errors result))))
               (setf all-errors (append all-errors stage-errors)))
             ;; Stop if stage doesn't allow continuation
             (unless (validation-stage-continue-on-failure stage)
               (return))))))
      (if all-errors
          (make-failure all-errors)
          (make-success current-value)))))

(defun run-stages (stages value)
  "Run validation stages on a value"
  (funcall (multi-stage stages) value))